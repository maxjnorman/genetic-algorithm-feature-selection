Notes 1

stackoverflow.com/multiprocessing1
https://stackoverflow.com/questions/11536764/how-to-fix-attempted-relative-import-in-non-package-even-with-init-py/27876800#27876800

def chain(*iterables):
  for iterable in iterables:
    yield from iterable

class CladeBase:
  def __init__(self,**kwargs):
    self._descs=descendants
    self.gen=0
    self.n_max=n_max #living individuals
    self.len_max=len_max #max len descs
    self.X=X
    self.y=y
    self._model=model
    self._oob=None
  @property
  def alive(self):
    return bool(self.size)
  @property
  def descs(self):
    self._descs=[d for d in self._descs
                           if d.alive]
    sizes=[d.size for d in self._descs]
    self._descs=self._descs[-argsort(sizes)]
    yield from self._descs
  @property
  def size(self):
    total=0
    sizes=(d.size for d in self.descs)
    for size in sizes:
      total+=size
    return total
  def part(self,iter,n=2):
    part=rep([],n)
    tally=rep(0,n)
    for item in iter:
      part[argmin(tally)].append(item)
      tally[argmin(tally)]+=item.size
    return part
  def comp(self,iters):

  def champ(self,loser=false):
    stable=list(self.descs)
    while len(stable)>1:
      arena=self.comp(self.part(stable,2))
      #arena sorts by shared mse
      if loser is true:
        stable=arena[-1]
      else:
        stable=arena[0]
    return stable[0]
  @property
  def highlander(self):
    return self.champ().champ()
  @property
  def fertile(self):
    for desc in self.descs:
      if desc.fertile:
        return true
    return false
  @property
  def baggage(self):
    return self.champ(false).champ(false)
  def kill(self):
    self.baggage().kill()
  @property
  def oob(self):
    est=nan(self.y.shape[0])
    if not self._oob is None:
      put(est,self._oob[0],self._oob[1])
    return est
  def clade(self):
    clade=(d.clade for d in self.descs)
    yield from clade
  def branch(self):
    n=ceil(self.size<self.n_max)
    if n > 1
      n=min([n,n_max])

    else:
      return [self]






class Individual(CladeBase):
  # todo init stuff
  def __init__(self,**kwargs):
    super().__init__(**kwargs)
    self.alive=true
    self.fertile=false
  @property
  def clade(self):
    clade=chain(d.descs for d in self.descs)
    yield from chain([self]), clade)
  def kill(self):
    if len(list(self.descs))>1:
      sample(self.descs,1).kill()
    else:
      self.alive=false
  def branch(self):
    yield from chain([self],self.descs)








class Clade:
  -refactor into Clade(CladeBase)
  descs: list of individuals (descendants)
    return living only
  len_max: max len of descs
  n: target size
  gen: generation counter
  data: data set
  target: y values
  fit(X,y):
    call descs.fit(X,y)
  size(): return n total
    call sum desc.size
  champ(): get one good individual
    get n=2 rand from living descs
    discard least fit if tie rand
    call champ on remaining desc
    return champ
    ALTERNATE:
      split descs in half (by size)
      keep fitter half
      repeat until single desc remains
      champ = highlander #last remaining
      call champ.champ
      return champ

  worst(): get one bad individual
     same as champ but the loser
  kill(): remove an individual
    call worst.kill
  prune(n): reduce population size
    while size > n
      call kill
  grow(n): increase population size
    while size < n
      call breed()
    call prune(n)
  tidy(): reorganise tree structure
    call descs.tidy
    call descs.branch for.each if.branch
      make Clade
        each.set descs=branch
    call elevate
    call simplify
  elevate(): remove non branching nodes
    for desc in descs
      if len(desc.descs)==1
        descs.append(desc.descs)
        desc.descs = []
  simplify(): combine complex descs
    sort descs by desc.descs.len
    for desc in descs
      space=len_max-descs.len
      if desc.descs.len <= space+1
        descs.append desc.descs
        desc.descs=[] # alive=false
  alive(): has descs
    return size > 0
  breed(): breed descs
    call descs.breed
    get n=2 rand desc
    ALTERNATIVE:
      split descs in half (by size)
      keep fitter half
      repeat till single winner and runner up
      fittest.descs.append(child)
      child made from runner up and fittest
    if draw pick random
    else fittest set fertile=true
      if both.fertile & rand<p_breed
        get new individual from both.champs
        if rand<p_mutate call mutate
        add to parent descs
          assign rand prop to fitness
           -fitness=1/mse
           -then normalise = weights
        set both.fertile=false
      else if rand<p_mutate
        add fittest.champ.mutate to descs
  branch(): split up descs
    if size > len_max
      n=ceil(size/len_max)
      n=min(n,len_max)
      divide descs into n (by size)
        assign each to current smallest
        use np.argmin(descs.size)
      output = [new Clade for each in n]
      call branch on each clade in output
      return output
    else
       return None
  oobs(): return out of bag estimates
    call recursively on descs
    return stack desc.oobs
    stack oobs just before fitness test
  individuals(): get all individuals
    call descs.individuals list[list[]]
    flatten one level
    -use for multiprocessing? for fitting?
  next(): next generation
    call fit or call mp.imap.individuals.fit
    ngen = ceil(.5*(gen%n)+.5*n)
    for i in range size
      call breed
      call prune(ngen)
      call tidy

class Individual(CladeBase)
  descs: inherited from CladeBase
  fertile: inherited from CladeBase
  data: inherited from CladeBase
  data: init empty
  len_max: 1
  n: 1
  fertile: init false
  champ(): return good individual
    if not descs return self
    get n=1 rand descs and self
    return fittest
  worst(): return poor individual
    same as champ but least fit
  individuals(): return [self] + descs
  branch(): split descendants
    if descs return [self] + descs
    else return None
  size(): return len(descs) + 1
  kill(): set alive = false
  elevate(): pass
  bury(): drop dead descs
  breed(): pass
  tidy(): call bury
  fit(X,y):
    split idx into train-test
    model.fit(bootstrap(X[train],y[train]))
    _oob = (model.predict(X[test]))
  oob: init None
  oob(): oob predictions
    out=np.nan(shape=data.size)
    if oob np.put(out,oob[1],oob[0])
    return out
